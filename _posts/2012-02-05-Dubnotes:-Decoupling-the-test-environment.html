---           
layout: post
title: Dubnotes: Decoupling the test environment
date: 2012-02-05 19:12:54 UTC
updated: 2012-02-05 19:12:54 UTC
comments: false
categories: Dubnotes
---

To create more and better tests, I have to decouple the system from the live Dropbox environment, because my tests need to be reliable and quick. <br /><br /><a name='more'></a><br /><br /><br />Both, the Dropbox and the Appengine API calls are used very often in the MainPage class. It would be logical to move the API calls out of the class and wrap them them to protect the class from further change of the API. <br /><br />There a two parts:<br /><ol><li>Decoupling Dropbox API calls from the app</li><li>Doing the same for the Appengine Datastore calls</li></ol>The Dropbox API calls are splattered all around in the code, e.g:<br /><br /><pre class="brush: py;">ret = db_client.metadata (config['root'], config['dubnotes_folder'])<br />if ret.status == 403:<br />&nbsp;&nbsp;&nbsp; db_client.create_folder (config['root'], config['dubnotes_folder'])<br /></pre><br />and<br /><br /><pre class="brush: py;">db_client.file_delete(config['root'], self.request.get('fname'))<br /></pre><br /><br /><br /><b>Part 1: Writing a fake Dropbox client</b><br /><br />Since I can not run Dropbox locally, I decided to write a fake Dropbox Client module, because the Dropbox API calls are deeply nested inside the MainPage Class and I could not extract them safely without breaking the whole thing.<br /><br />Writing a fake Dropbox leaves me in the danger of running my tests against the wrong target, but I can live with that until the main refactoring is done. The improvements in speed and the safe testing environment seems to be worth it.<br /><br />How do I start?<br /><br />The Dropbox client API module is not large. It consists of 4 files:<br /><br />__init__.py  - 0 lines of code<br />auth.py      - 222 lines of code<br />client.py    - 278 lines of code<br />rest.py      - 90 lines of code<br /><br />Most of the lines (roughly 40-50 percent) are comments, so this is quite small. There are only a few different types od calls dubnotes.py makes directly towards this module, so probably I can leave out the rest and just fake a little bit.<br /><br />I start by creating a module called "fake_dropbox" and copying the files from the original Dropbox client in. I change the dubnotes.py to load my module:<br /><br /><pre class="brush: py;">from fake_dropbox import client, rest, auth<br />#from dropbox import client, rest, auth<br /></pre><br />My tests all pass (so far), everything is fine.<br /><br />In the next step I deleted everything with auth.py and client.py, except for the class and method definitions and their return statements to get an idea of the class and methods signature I have to fake:<br /><br /><pre class="brush: py;">class SimpleOAuthClient(oauth.OAuthClient):<br />&nbsp;&nbsp;&nbsp; def __init__(self, server, port=httplib.HTTP_PORT, request_token_url='', access_token_url='', authorization_url=''):<br /><br />&nbsp;&nbsp;&nbsp; def fetch_request_token(self, oauth_request):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return oauth.OAuthToken.from_string(data)<br /><br />&nbsp;&nbsp;&nbsp; def fetch_access_token(self, oauth_request, trusted_url=None):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return oauth.OAuthToken(token['token'], token['secret'])<br /><br />&nbsp;&nbsp;&nbsp; def authorize_token(self, oauth_request):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise NotImplementedError("authorize_token is not implemented via OAuth.")<br /><br />&nbsp;&nbsp;&nbsp; def access_resource(self, oauth_request):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise NotImplementedError("access_resource is not implemented via OAuth.")<br /><br />class Authenticator(object):<br />&nbsp;&nbsp;&nbsp; def __init__(self, config):<br /><br />&nbsp;&nbsp;&nbsp; @classmethod<br />&nbsp;&nbsp;&nbsp; def load_config(self, filename):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return dict(config.items('auth'))<br /><br />&nbsp;&nbsp;&nbsp; def build_authorize_url(self, req_token, callback=None):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return "%s?oauth_token=%s%s" % (self.config['authorization_url'], req_token.key, oauth_callback)<br /><br />&nbsp;&nbsp;&nbsp; def obtain_request_token(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return token<br /><br />&nbsp;&nbsp;&nbsp; def obtain_access_token(self, token, verifier):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return token<br /><br />&nbsp;&nbsp;&nbsp; def obtain_trusted_access_token(self, user_name, user_password):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return token<br /><br />&nbsp;&nbsp;&nbsp; def build_access_headers(self, method, token, resource_url, parameters, callback=None):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return self.oauth_request.to_header(), params<br /><br /></pre><br />After some trial and error and a lot of testing I turned this into this:<br /><br /><pre class="brush:py;">from ConfigParser import SafeConfigParser<br />from oauth import oauth<br /><br />class Authenticator(object):<br />&nbsp;&nbsp;&nbsp; def __init__(self, config):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pass<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; @classmethod<br />&nbsp;&nbsp;&nbsp; def load_config(self, filename):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; """<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Loads a configuration .ini file, and then pulls out the 'auth' key<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to make a dict you can pass to Authenticator().<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; """<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; config = SafeConfigParser()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; config_file = open(filename, "r")<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; config.readfp(config_file)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return dict(config.items('auth'))<br /><br />&nbsp;&nbsp;&nbsp; def build_authorize_url(self, req_token, callback=None):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return "http://localhost:8080/?uid=user&amp;oauth_token=a_request_token" <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; def obtain_request_token(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return oauth.OAuthToken('a_request_token', 'a_request_secret')<br /><br />&nbsp;&nbsp;&nbsp; def obtain_access_token(self, token, verifier):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return oauth.OAuthToken('an_access_token', 'an_access_secret')<br /><br />&nbsp;&nbsp;&nbsp; def obtain_trusted_access_token(self, user_name, user_password):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return oauth.OAuthToken('a_trusted_access_token', 'a_trusted_access_secret')<br /></pre><br />The class now has the same signature but every method call answers with default values. I completely removed the SimpleOAuthClient, since it isn´t used.<br /><br />I did the same for the client.py file, which was a lot harder to overcome:<br /><ul><li>I created a FakeHTTPResponse class, which has no real socket or file output and methods to pre-populate the data it returns (useful for the tests).</li><li>All the methods in DropboxClient class simply return an instance of FakeHTTPResponse.</li></ul>Note that I added two class methods into DropboxClient, set_demo_data and set_demo_status which are used to pass status and data into the FakeHTTPResponse before an instance gets created from within Dubnotes.<br /><br /><b>Part 2: Decoupling Appengine</b><br /><br />The only reason I can not just create an instance of Mainpage in my own program instead of using the dev_appserver.py webserver is that it does not run inside of the Appengine-SDK environment and therefore fails in accessing the appengine datastore.<br /><br />But I want to do that, so I fake the Appengine database API, the same way I faked the Dropbox client API:<br /><ul><li>creating a folder called "fake_db"</li><li>creating an __init__.py and db.py file</li><li>create a Model-class (this is all we need)</li><li>comment out the old import statement in dubnotes.py and plug my fake_db class in</li></ul><br /><pre class="brush:py;">from fake_db import db<br />#from google.appengine.ext import db<br /></pre><br />After a bit of testing and playing around with the API the db.py module looks like this:<br /><br /><pre class="brush:py;">class Model(object):<br />&nbsp;&nbsp;&nbsp; @classmethod<br />&nbsp;&nbsp;&nbsp; def get_by_key_name(self, key_name):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if key_name == "nonexisting_user":<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return None<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Model(key_name)<br />&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; def __init__(self, key_name):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #print "--&gt; called with keyname %s" % key_name<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if key_name == "user":<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.access_key = 'an_access_key'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.access_secret = 'an_access_secret'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.uid = 'user'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.req_key = "a_request_key"<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.req_secret = 'a_request_secret'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.datetime= datetime(2012, 01, 01, 00, 00,00)<br />&nbsp;&nbsp;&nbsp; def put(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pass<br />&nbsp;&nbsp;&nbsp; <br />def StringProperty():<br />&nbsp;&nbsp;&nbsp; pass<br /><br />def DateTimeProperty():<br />&nbsp;&nbsp;&nbsp; pass<br /></pre><br />StringProperty() and DateTimeProperty() are used inside appengine to define the data model, but we have no actual use for them so we just do nothing.<br /><br />The solution presented here is not dynamic, the if statement is very ugly, and needs to be removed. <br /><br />There is a factory-method get_by_key_name which returns an instance of Model depending on 3 different input values ("non_existing_user", "user", anything else), so I refactored it to this:<br /><br /><pre class="brush:py;">class Model(object):<br />&nbsp;&nbsp;&nbsp; @classmethod<br />&nbsp;&nbsp;&nbsp; def get_by_key_name(self, key_name):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if key_name == "user":<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return UserModel(key_name)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif key_name == "nonexisting_user":<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return None<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TokenModel(key_name)<br />&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; def __init__(self, key_name):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pass<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; def put(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pass<br />&nbsp;&nbsp;&nbsp; <br />class TokenModel(Model):<br />&nbsp;&nbsp;&nbsp; def __init__(self, key_name):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super(TokenModel, self).__init__(key_name)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.req_key = "a_request_key"<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.req_secret = 'a_request_secret'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.datetime= datetime(2012, 01, 01, 00, 00,00)<br /><br />class UserModel(Model):<br />&nbsp;&nbsp;&nbsp; def __init__(self, key_name):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super(UserModel, self).__init__(key_name)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.access_key = 'an_access_key'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.access_secret = 'an_access_secret'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.uid = 'user'<br /></pre><br />I could get rid of the if-statement when using persistence, but for now this is okay.<br /><br /><br />Part 3: Website rendering, Django<br /><br />The Django web-framework is encapsulated into appengine and gets called by dubnotes.py every time it creates a response.<br /><br /><pre class="brush:py;">template_values={'delete_url':' /?uid=' + user.uid + '&amp;oauth_token='+ token.req_key + '&amp;fname=' +fname+ '&amp;action=delete',<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'url':'/?uid=' + user.uid + '&amp;oauth_token='+ token.req_key, <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'content': content, <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'fname': fname,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'showname': os.path.basename(fname)}<br />path = os.path.join(os.path.dirname(__file__), 'editpage.html')<br />self.response.out.write(<span style="color: red;">template.render(path, template_values)</span>)<br /></pre><br />Since this part of the framework runs nicely when called from my IDE or depends on external resources, I do not need to decouple it from anything.<br /><br />When I instantiate the MainPage-class I replace the "self.response" with an instance of the "StdOutRedirector" which basically gives me everything the app would write out to the web (e.g. the rendered webpages) into an string.<br /><br /><pre class="brush:py;">class PseudoSocket(object):<br />&nbsp;&nbsp;&nbsp; def write(self, stuff):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.data = stuff<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />class StdOutRedirector:<br />&nbsp;&nbsp;&nbsp; def __init__(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.out = PseudoSocket()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.headers = {}<br />&nbsp;&nbsp;&nbsp; def set_status(self, status):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.status = status<br />&nbsp;&nbsp;&nbsp; def clear(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pass<br /></pre><br /><br /><br /><b>Part 4: More Tests</b><br /><br />Having things so nicely decoupled from every external dependency, I wrote some more tests and use the "coverage" tool <a href="http://nedbatchelder.com/code/coverage/">[1]</a> to have the unittests cover about 90 % of the source.<br /><br />This file is quite long, but can bee seen here : <a href="https://github.com/dubspeed/dubnotes/blob/master/dubnotes_tests.py">dubnotes_tests.py</a><br /><br /><b>Conclusion</b><br /><br />Writing a fake Dropbox and a fake datastore client helped me a lot to write more unittests, which run quickly and cover a lot of code in the current app. I did not touch the sources of the dubnotes.py application itself, but it now time to do so and to re-factor the app completely.<br /><br />Of course in the end all tests and functionality has to run against the live version of both APIs, but I hope the time spend on the fake versions pays back when I re-factor. Keeping in mind that these tests aren´t real, I have to run the suite against the original versions from time to time, just to make sure it behaves okay. <br /><br />[1] http://nedbatchelder.com/code/coverage/<br />[2] https://github.com/dubspeed/dubnotes/blob/master/dubnotes_tests.py