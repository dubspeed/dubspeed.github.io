---           
layout: post
title: Dubnotes - Refactoring - Part II - The Authenticator
date: 2012-02-12 14:21:28 UTC
updated: 2012-02-12 14:21:28 UTC
comments: false
categories: Dubnotes
---

In this post I am taking the big monolithic "quick_auth" method and refactor it into something a little better.<br /><br /><a name='more'></a><br /><b>The case&nbsp; </b><br /><br />In the last post I moved the "quick_auth" function from the main class into a seperate class called "Authenticator".<br /><br />My tests broke badly, but I learned a lot about the method and its dependencies. Now I am looking again into the class and the Authenticator, to make it a better citizen and to split it up more and more into good readable code.<br /><br />Here, for reference, is the original methods:<br /><pre class="brush:py;">&nbsp;&nbsp;&nbsp; def quick_auth(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # check if we have a uid in the request<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uid = self.request.get('uid')<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; config = auth.Authenticator.load_config ("dubnotes.ini")<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dba = auth.Authenticator(config)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db_client = None<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if uid == "":<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; authenticate(self, config, dba)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # check if we have that token<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req_token = self.request.get('oauth_token')&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; token = DropToken.get_by_key_name (req_token)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if token:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # we have that token, now we learned the uid for that request<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # do we have a access token for that user?<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; user = User.get_by_key_name (uid)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if user:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; access_token = oauth.OAuthToken(str(user.access_key), str(user.access_secret))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # create a new user entry and try to get an access token<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req_token = oauth.OAuthToken(str(token.req_key), str(token.req_secret))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; access_token = dba.obtain_access_token (req_token, config['verifier'])<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; user = User (key_name=uid)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; user.uid = uid<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; user.access_key = access_token.key<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; user.access_secret=access_token.secret<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; user.put()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db_client = client.DropboxClient(config['server'], config['content_server'], <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; config['port'], dba, access_token)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return config, db_client, token, user <br /><br /></pre>I draw a quick outline of what the "quick_auth" method is actually doing, and to get an idea about the nasty "if" cascade it contains.<br /><br /><pre class="brush:py;">is a user id in the request?<br />YES<br />&nbsp;&nbsp;&nbsp; is a oauth_token in the request?<br />&nbsp;&nbsp;&nbsp; YES<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is the token in the database?<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; YES<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Is the user in the database?<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; YES<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get access token from database<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NO <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obtain a new access token, store it in database<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Generate Dropbox Client and finish!<br />NO (authenticator method)<br />&nbsp;&nbsp;&nbsp; obtain a request token, store it in database<br />&nbsp;&nbsp;&nbsp; redirect user to dropbox website<br /></pre><br />You see, some cases of the "if" casced are not handling their "no" part. What if the token is not in the database or not in the request string? The future code should consider these cases and react correctly.<br /><br /><b>Lets start</b><br /><br />Here is the head of the Authenticator class:<br /><br /><pre class="brush:py;">class Authenticator:<br />&nbsp;&nbsp;&nbsp; def __init__ (self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.config = auth.Authenticator.load_config ("dubnotes.ini")<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.dropbox_auth = auth.Authenticator(self.config)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.user = self.token = self.dropbox_client = None<br /></pre><br />The user, token, and dropbox_clients are the result of authentication process. Right now I access them directly from within the MainPage-class. <br /><br />So, here is what authenticate function looks like:<br /><br /><pre class="brush:py;">&nbsp;&nbsp;&nbsp; def authenticate(self, reqhandler, config, dba):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Get an authenticator for the app <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Get the request token<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req_token = dba.obtain_request_token()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # store token for later<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; token = DropToken (key_name=req_token.key)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; token.req_key = req_token.key<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; token.req_secret = req_token.secret<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; token.datetime = datetime.now()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; token.put()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; authorize_url = dba.build_authorize_url(req_token, reqhandler.request.uri)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #send to authenticator webpapge,&nbsp; may he return...<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reqhandler.redirect(authorize_url)<br /><br /></pre>And here is the same after refactoring it into three shiny new methods:<br /><br /><pre class="brush:py;">&nbsp;&nbsp;&nbsp; def obtain_request_token(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return self.dropbox_auth.obtain_request_token()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; def db_store_request_token(self, req_token):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; token = DropToken (key_name=req_token.key)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; token.req_key = req_token.key<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; token.req_secret = req_token.secret<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; token.datetime = datetime.now()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; token.put()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; def redirect_to_dropbox(self, reqhandler, config, dropbox_auth):&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; authorize_url = dropbox_auth.build_authorize_url(req_token, reqhandler.request.uri)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #send to authenticator webpapge,&nbsp; may he return...<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reqhandler.redirect(authorize_url)</pre><pre class="brush:py;"></pre>I renamed the "dba" to dropbox_authenticator, because the old name is misleading (it has nothing to do with databases).<br /><br />I split the function into three parts: <br /><ul><li>obtain_request_token just wraps a call to the dropbox_authenticator</li><li>db_store_request_token wraps a call to the Appengine-API and the persistence API</li><li>the redirect_to_dropbox method has still two responsibilities: build the url and the redirect. </li></ul>The request-Handler used here is the "MainPage"-class (a child of webapp.RequestHandler). It seems natural that the redirect should take place in the "MainPage" class, not here. So, I removed the redirect, and moved all back into MainPage:<br /><br /><pre class="brush:py;">&nbsp;&nbsp;&nbsp; def authenticate_user(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.authenticator = Authenticator()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.decide_authentication_path()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.dropbox_client = self.authenticator.dropbox_client<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.user = self.authenticator.user<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.config = self.authenticator.config<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.token = self.authenticator.token<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; except:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise AuthenticationException("Authentication error.")<br /><br />&nbsp;&nbsp;&nbsp; def decide_authentication_path(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if self.is_valid_uid_in_request():<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uid = self.get_uid_from_request()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oauth_token = self.get_oauth_token_from_request()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.authenticator.reauthenticate_user(uid, db_get_token(oauth_token))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; token = self.authenticator.obtain_request_token()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db_store_token(token)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.redirect_to_dropbox(token, self.authenticator.dropbox_auth)<br /><br />&nbsp;&nbsp;&nbsp; def is_valid_uid_in_request(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if self.get_uid_from_request() == "":<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return False<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return True<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; def get_uid_from_request(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uid = self.request.get('uid') <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return uid<br /><br />&nbsp;&nbsp;&nbsp; def get_oauth_token_from_request(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oauth_token = self.request.get('oauth_token') <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return oauth_token<br /><br />&nbsp;&nbsp;&nbsp; def redirect_to_dropbox(self, token, dropbox_auth):&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; authorize_url = dropbox_auth.build_authorize_url(token, self.request.uri)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.redirect(authorize_url)<br /></pre>&nbsp; <br />I extracted all the database wrapper/calls and moved them into four module-wide functions: <br /><br /><pre class="brush:py;">def db_get_token(token):<br />&nbsp;&nbsp;&nbsp; return DropToken.get_by_key_name (token)<br /><br />def db_store_token(token):<br />&nbsp;&nbsp;&nbsp; t = DropToken (key_name=token.key)<br />&nbsp;&nbsp;&nbsp; t.req_key = token.key<br />&nbsp;&nbsp;&nbsp; t.req_secret = token.secret<br />&nbsp;&nbsp;&nbsp; t.datetime = datetime.now()<br />&nbsp;&nbsp;&nbsp; t.put()<br />&nbsp;&nbsp;&nbsp; return t<br /><br />def db_get_user (uid):<br />&nbsp;&nbsp;&nbsp; return User.get_by_key_name (uid)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />def db_store_user (uid, key, secret):<br />&nbsp;&nbsp;&nbsp; u = User(key_name=uid)<br />&nbsp;&nbsp;&nbsp; u.uid = uid<br />&nbsp;&nbsp;&nbsp; u.access_key = key<br />&nbsp;&nbsp;&nbsp; u.access_secret = secret<br />&nbsp;&nbsp;&nbsp; u.put()&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; return u<br /></pre><br />I refactored the "reauthenticate" method, formerly known as "quick_auth", there is still work to do here:<br /><br /><pre class="brush:py;">&nbsp;&nbsp;&nbsp; def reauthenticate_user(self, uid, token):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if token:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.token = token<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.user = db_get_user(uid)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if self.user:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; access_token = oauth.OAuthToken(str(self.user.access_key), str(self.user.access_secret))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # create a new user entry and try to get an access token<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oauth_token = oauth.OAuthToken(str(token.req_key), str(token.req_secret))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; access_token = self.dropbox_auth.obtain_access_token (oauth_token, self.config['verifier'])<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.user = db_store_user(uid, access_token.key, access_token.secret)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.dropbox_client = client.DropboxClient(self.config['server'], self.config['content_server'],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.config['port'], self.dropbox_auth, access_token)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # case not handled ... ?<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pass</pre><pre class="brush:py;">&nbsp;</pre><pre class="brush:py;"></pre>I left the nasty looking "if" statement to remind me to think about the special case in which there is no token or a "null". This case was never considered in the old version of the function, so handling this correctly should be an improvement.<br /><br /><b>Conclusion</b><br /><br />The old way to authenticate users has been split up into a class and  some functions. The database calls have been isolated a bit and all of  code now makes a lot of more sense.<br />As always, all the tests pass.<br /><br />There are some key points left to do:<br /><ul><li>The interface between the Authenticator class and the MainPage right now is stupid, just passing some instance variables around. Encapsulate! There should be an "AuthenticatedSession" Class to keep all the data.</li><li>We need to handle the cases which were left in the original "quick_auth" method.</li></ul><b>Next </b><br /><br />In the next episode, I am going to clean the code up even more and implement the AuthenticatedSession class. In my first UML design sketch I had no idea about this class, but now it seems to make perfect sense to me.<br /><br /><br />
