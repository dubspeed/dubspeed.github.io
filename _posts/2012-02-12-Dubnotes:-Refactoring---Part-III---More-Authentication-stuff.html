---           
layout: post
title: Dubnotes: Refactoring - Part III - More Authentication stuff
date: 2012-02-12 14:21:06 UTC
updated: 2012-02-12 14:21:06 UTC
comments: false
categories: Dubnotes
---

In my previous post I was talking about the authenticator and the quick_auth method, which I split into several pieces. I continue where I left off last time.<br /><br /><a name='more'></a>Please take a look at the current version of <a href="https://github.com/dubspeed/dubnotes/blob/e42989cdc533b099a65cf09888475ff7884660dc/dubnotes.py">dubnotes.py</a>, the Authenticator class looks like this:<br /><br /><pre class="brush:py;">class Authenticator:<br />&nbsp;&nbsp;&nbsp; def __init__ (self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.config = auth.Authenticator.load_config ("dubnotes.ini")<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.dropbox_auth = auth.Authenticator(self.config)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.user = self.token = self.dropbox_client = None<br /><br />&nbsp;&nbsp;&nbsp; def obtain_request_token(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return self.dropbox_auth.obtain_request_token()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; def reauthenticate_user(self, uid, token):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if token:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.token = token<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.user = db_get_user(uid)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if self.user:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; access_token = oauth.OAuthToken(str(self.user.access_key), str(self.user.access_secret))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # create a new user entry and try to get an access token<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oauth_token = oauth.OAuthToken(str(token.req_key), str(token.req_secret))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; access_token = self.dropbox_auth.obtain_access_token (oauth_token, self.config['verifier'])<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.user = db_store_user(uid, access_token.key, access_token.secret)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.dropbox_client = client.DropboxClient(self.config['server'], self.config['content_server'],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.config['port'], self.dropbox_auth, access_token)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # case not handled ... ?<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pass<br /></pre><br />In my last post I said that the self.user, self.token and self.dropbox_client would fit into a "AuthenticatedSession" class, but after some consideration I came to the conclusion that this class actually <i>is</i> the Authenticator. <br /><br />Just to get a better feeling for the reauthenticate_user method I split it into several pieces:<br /><br /><pre class="brush:py;">class Authenticator:<br />    def __init__ (self):<br />        self.config = auth.Authenticator.load_config ("dubnotes.ini")<br />        self.dropbox_auth = auth.Authenticator(self.config)<br />     <br />    def reauthenticate_user (self, uid, request_token):<br />        self.set_request_token(request_token)<br />        self.get_user_and_access_token(uid)<br />        self.dropbox_client = client.DropboxClient(self.config['server'], self.config['content_server'],<br />                                                   self.config['port'], self.dropbox_auth, self.access_token)<br />    <br />    def set_request_token(self, request_token):<br />        self.request_token = request_token    <br />    <br />    def get_user_and_access_token(self, uid):<br />        self.user = db_get_user(uid)<br />        if self.user:<br />            get_access_token<br />        else:<br />            obtain_access_token<br />            self.user = create_user<br />      <br />    def get_access_token(self):<br />        self.access_token = oauth.OAuthToken(str(self.user.access_key), str(self.user.access_secret))<br /><br />    def obtain_access_token(self):<br />        oauth_token = oauth.OAuthToken(str(self.request_token.req_key), str(self.request_token.req_secret))<br />        self.access_token = self.dropbox_auth.obtain_access_token (oauth_token, self.config['verifier'])<br />    <br />    def create_user(self):<br />        return db_store_user(uid, self.access_token.key, self.access_token.secret)<br />      <br />    def obtain_request_token(self):<br />        return self.dropbox_auth.obtain_request_token()<br /></pre><br />I think this is quite readable. Additionally I restructured the following methods in the MainPage class:<br /><br /><pre class="brush:py;">&nbsp;&nbsp;&nbsp; def authenticate_user(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.auth = Authenticator()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if self.is_valid_uid_in_request() and self.is_valid_request_token_in_request():<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.authenticate_known_user()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.redirect_unknown_user()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; except:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise AuthenticationException("Authentication error.")<br /><br />&nbsp;&nbsp;&nbsp; def authenticate_known_user(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uid = self.get_uid_from_request()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; request_token = self.get_request_token_from_request()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.auth.reauthenticate_user(uid, db_get_token(request_token))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; def redirect_unknown_user(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; token = self.auth.obtain_request_token()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db_store_token(token)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.redirect_to_dropbox(token, self.auth.dropbox_auth)</pre><br />Which I find readable as well, but there are still some issues left with this code which I donÂ´t like. First, there is too much authentication code in the Mainpage class, that really should move out of it. Why should the code bother to care about all conditions are met for successful authentication?&nbsp; <br /><br />The above code can be refactored by applying the factory pattern[1].<br /><br /><pre class="brush:py;">class SessionFactory:<br />&nbsp;&nbsp;&nbsp; @staticmethod <br />&nbsp;&nbsp;&nbsp; def create(request):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if request.get('uid') == None or request.get('oauth_token') == None:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return RedirectedSession(request)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return AuthenticatedSession(request)<br /></pre><br />Note: In Python the factory could as well be written as module-wide function (without the "class" and the "@staticmethod" descriptor), because the factory does not need any instance of SessionFactory.<br /><br />I introduce the "Session" class and it derivatives, "RedirectedSession" and "AuthenticatedSession":<br /><br /><pre class="brush:py;">class Session(object):<br />&nbsp;&nbsp;&nbsp; def __init__ (self, request):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.config = auth.Authenticator.load_config ("dubnotes.ini")<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.dropbox_auth = auth.Authenticator(self.config)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.request = request<br />&nbsp; <br />&nbsp;&nbsp;&nbsp; def needs_redirect(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return False<br />&nbsp;<br />class RedirectedSession(Session):<br />&nbsp;&nbsp;&nbsp; def __init__(self, request):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super(RedirectedSession, self).__init__(request)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.request_token = None<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; def get_authorization_url(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.request_token = self.obtain_request_token()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db_store_token(self.request_token)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; authorize_url = self.dropbox_auth.build_authorize_url(self.request_token, self.request.uri)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return authorize_url<br /><br />&nbsp;&nbsp;&nbsp; def obtain_request_token(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return self.dropbox_auth.obtain_request_token()<br /><br />&nbsp;&nbsp;&nbsp; def needs_redirect(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return True<br /><br />class AuthenticatedSession(Session):<br />&nbsp;&nbsp;&nbsp; def __init__(self, request):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super(AuthenticatedSession, self).__init__(request)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.uid = self.request.get('uid')<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.request_token = db_get_token(self.request.get('oauth_token'))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.access_token = None<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.user = None<br /><br />&nbsp;&nbsp;&nbsp; def authenticate_user (self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.get_user_and_access_token()<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; def get_user_and_access_token(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.user = db_get_user(self.uid)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if self.user:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.get_access_token()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.obtain_access_token()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.user = self.create_user()<br />&nbsp; <br />&nbsp;&nbsp;&nbsp; def get_access_token(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.access_token = oauth.OAuthToken(str(self.user.access_key), str(self.user.access_secret))<br /><br />&nbsp;&nbsp;&nbsp; def obtain_access_token(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oauth_token = oauth.OAuthToken(str(self.request_token.req_key), str(self.request_token.req_secret))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.access_token = self.dropbox_auth.obtain_access_token (oauth_token, self.config['verifier'])<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; def create_user(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return db_store_user(self.uid, self.access_token.key, self.access_token.secret)<br /></pre><br />This is my solution to the authentication process. It encapsulated everything the quick_auth method does, seperates it into several classes, it is a lot more readable and takes stress from the main class. The Mainpage simply delegates the task of creating a Session to the factory, which either returns a "redirected" or "authenticated" session.<br /><br />It is still not perfect, but okay for now and I leave it like that. The final code can be viewed here: <a href="https://github.com/dubspeed/dubnotes/blob/14826a02349ac1ea1c68922f9b7124e8fbd30a7a/dubnotes.py">dubnotes.py</a><br /><br /><b>Tests and testing</b><br /><br />Since I have a test class which covers 99% of the source, I was just keeping the current test passing against the changing code. <br />While developing the code above I found some interesting flaws in the original design like unhandled if-else cases and errors when handling partital authentication (if you are interested, see the "testPartitialAuthentication" method).<br /><br /><b>Conclusion</b><br /><br />Refactoring the authentication process was a tough job, but I am very satisfied with the result. It should be easy to maintain and change in the future and it is easy to understand and read.<br /><br /><b>Next</b><br /><br />The next task is housekeeping.&nbsp; I will split up the classes into separate files and create unit tests for each of the classes. <br /><b><br /></b><br /><b>References</b><br /><br />[1] http://en.wikipedia.org/wiki/Factory_method_pattern<br /><br /><br /><br />