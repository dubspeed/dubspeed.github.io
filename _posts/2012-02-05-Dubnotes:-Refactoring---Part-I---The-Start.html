---           
layout: post
title: Dubnotes - Refactoring - Part I - The Start
date: 2012-02-05 19:12:47 UTC
updated: 2012-02-05 19:12:47 UTC
comments: false
categories: Dubnotes
---

Making some plans on the design and starting to move the code of the app around.<br /><br /><a name='more'></a><br /><br /><br /><b>Planning the redesign</b><br /><br /><br />I started with a quick UML get an idea of how the system should be after I rewrote it.<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/-SkBI2IEiL3k/TyWXFeWHdII/AAAAAAAAAF0/QCYq5xsmHJE/s1600/Bildschirmfoto+2012-01-29+um+19.58.37.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="260" src="http://3.bp.blogspot.com/-SkBI2IEiL3k/TyWXFeWHdII/AAAAAAAAAF0/QCYq5xsmHJE/s400/Bildschirmfoto+2012-01-29+um+19.58.37.png" width="400" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Quick UML Diagram: How I think the system should look like (for now)</td></tr></tbody></table>This chart outlines the classes we are dealing with and how I think the instances should interact with each other. I am not too happy with the MainPage class having all the other object, and I am not sure about how many instances we need (do we need a one instance of each for every request?).<br /><br />I am putting the chart aside for now, I will return to it later when I learned more about the code.<br /><br /><br /><br /><br /><b>The code</b><br /><br />Okay, lets start rewriting the main code. Every web request like "get" and "put" has a corresponding method in the MainPage class which act as the apps entry point.<br /><br />At his point in time the app can not decide weather the incoming request is completely new or from a previously existing user interaction, so it has to check weather the session and the user is known or not. If not, it has to authenticate the user and get access to its Dropbox account and so on.<br /><br />I started with the get method: <br /><br /><pre class="brush:py;">&nbsp;&nbsp;&nbsp; def get(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; config, db_client, token, user = self.quick_auth()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; except:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.response.out.write('Authentication error.')<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # evaluate action<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; action = self.request.get('action')<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if action=='edit':<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.show_editor(config, db_client, token, user)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif action=='new':<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.create_new_file(config, db_client, token, user)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif action=='delete':<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db_client.file_delete(config['root'], self.request.get('fname'))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.list_view(config, db_client, token, user)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.list_view(config, db_client, token, user)<br /></pre><br />The get method is the main entry point of the application and controls the application flow. First it authenticates the user and, if successful, renders him a page or shows the famous "authentication error message". I clearly has too many responsibilities (authentication, error handling and flow control) and is too long.<br /><br />To show this intend better I wrote:<br /><br /><pre class="brush:py;">def get(self):<br />        try:<br />            self.authenticate_user()<br />        except AuthenticationException as e:<br />            self.display_authentication_error(e)<br />        else:<br />            self.evaluate_request()<br /></pre><br />Splitting the code into three new methods:<br /><br /><pre class="brush:py;">def authenticate_user(self):<br />       try:<br />          self.auth_data = self.quick_auth()<br />        except:<br />          raise AuthenticationException("Authentication error.")<br /><br />    def display_authentication_error(self, exception):<br />        self.repsonse.out.write (exception)<br /><br />    def evaluate_request(self):<br />        # evaluate action<br />        config, db_client, token, user = self.auth_data<br />        action = self.request.get('action')<br />        if action == 'edit':<br />          self.show_editor(config, db_client, token, user)<br />        elif action == 'new':<br />          self.create_new_file(config, db_client, token, user)<br />        elif action == 'delete':<br />          db_client.file_delete(config['root'], self.request.get('fname'))<br />          self.list_view(config, db_client, token, user)<br />        else:<br />          self.list_view(config, db_client, token, user)<br /></pre><br />and finally added a new Exception class:<br /><br /><pre class="brush:py;">class AuthenticationException(Exception):<br />    def __init__(self, message):<br />        self.message = message<br />    def __str__(self):<br />        return repr(self.message)<br /></pre><br />Since the "post" method looks exactly like the "get" method (authenticate, then do something), I could get rid of the code duplication and put them together like so:<br /><br /><pre class="brush:py;">def get(self):<br />        if self.force_authentication() == True:<br />            self.evaluate_get_request()<br /><br />    def post(self):<br />        if self.force_authentication() == True:<br />            self.evaluate_post_request()<br /><br />    def force_authentication(self):<br />        try:<br />            self.authenticate_user()<br />            return True<br />        except AuthenticationException as e:<br />            self.display_authentication_error(e)<br />        return False<br /></pre><br />The next thing I did was to split the authentication code from the class and move it into its own class "Authenticator".<br /><br />At first I got rid of the "return config, db_client, token, user"-statement at the end of "quick_auth" method by changing "config, db_client, token, user" to instance variables (self.config, etc.).<br /><br />Removing the "return" fails some tests and a lot of code, so I added "self." in all the places needed to make them pass.<br /><br />I also had to change the signatures of basically all the "view" methods where these parameters are used as inputs. That nearly changed every line of code in the file, but my tests work nice afterwards.<br /><br />Next, I moved the quick_auth method into the authenticator (which later turns out to be a mistake). I found out that this ain´t easy, since it is way to complex and has a lot of dependencies I couldn´t resolv. Lets look at the mess:<br /><br /><pre class="brush:py;">&nbsp;&nbsp;&nbsp; def quick_auth(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # check if we have a uid in the request<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uid = self.request.get('uid')<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.config = auth.Authenticator.load_config ("dubnotes.ini")<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dba = auth.Authenticator(self.config)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.db_client = None<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if uid == "":<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; authenticate(self, self.config, dba)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # check if we have that token<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req_token = self.request.get('oauth_token')&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.token = DropToken.get_by_key_name (req_token)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if self.token:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # we have that token, now we learned the uid for that request<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # do we have a access token for that user?<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.user = User.get_by_key_name (uid)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if self.user:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; access_token = oauth.OAuthToken(str(self.user.access_key), str(self.user.access_secret))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # create a new user entry and try to get an access token<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; req_token = oauth.OAuthToken(str(self.token.req_key), str(self.token.req_secret))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; access_token = dba.obtain_access_token (req_token, self.config['verifier'])<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.user = User (key_name=uid)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.user.uid = uid<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.user.access_key = access_token.key<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.user.access_secret = access_token.secret<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.user.put()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.db_client = client.DropboxClient(self.config['server'], self.config['content_server'],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.config['port'], dba, access_token)<br /></pre><br /><br />It makes frequent use of low-level API calls, has two nasty if-statements, and is way to long.<br />The comments above some statement could be easily rewritten in code:<br /><br /><pre class="brush:py;">&nbsp;&nbsp;&nbsp; def get_uid_from_request(self, request):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return request.get('uid')<br /></pre><br />Weather there is a valid UID in the request or not, the function takes two pathes and could be rewritten like this:<br /><br /><pre class="brush:py;">&nbsp;&nbsp;&nbsp; def quick_auth(self, request):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if valid_uid_in_request(request):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reauthenticate_user()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; authenticate(self, self.config, dba)<br /></pre><br />To check the request for a valid UID should not be in the   responsibility of the Authenticator, so the above code should later move  back  into the MainPage-class (for now).<br /><br />At this point in time I found all my tests broken because the method is heavily using instance variables which are expected to be in the MainPage-class. It even creates more of them. I could just undo the operation, but I decided to make it work where it was.<br /><br />Just to make my tests pass again (for now), I changed the signature of the function to accept a parameter:<br /><br /><pre class="brush:py;">def quick_auth(self, request_handler):<br /></pre><br />and recreate the instance variables in MainPage after calling the method:<br /><br /><pre class="brush:py;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; authenticator.quick_auth(self)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.db_client = authenticator.db_client<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.user = authenticator.user<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.config = authenticator.config<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.token = authenticator.token <br /></pre><br />Remember, this is just to make my tests pass again. I am feeling that this function is something I need to think about a lot more, so I am taking a break and continue to redesign it next time.&nbsp; <br /><br /><b>Lesson learned</b><br /><br />Moving the "quick_auth" method into the Authentication class was a bad idea, this method has way to many responsibilities and dependencies.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />The upside is, that I have learned about the dependencies this method has and what data and instance variables it uses and creates.<br /><br />Next up: make this nice :)<br /><br /><br /><br /><br />
